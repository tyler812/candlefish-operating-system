name: Deploy CLOS Core API to ECS
on:
  push:
    branches: [main]
    paths: ['services/clos-core-api/**']
  pull_request:
    branches: [main]
    paths: ['services/clos-core-api/**']
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      force_deploy:
        description: 'Force deployment even if tests fail'
        required: false
        default: false
        type: boolean

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: candlefish/clos-core-api
  ECS_CLUSTER: candlefish-clos
  ECS_SERVICE_STAGING: clos-core-api-staging
  ECS_SERVICE_PRODUCTION: clos-core-api-production
  CONTAINER_NAME: clos-core-api

jobs:
  determine-environment:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      should_deploy: ${{ steps.env.outputs.should_deploy }}
      ecs_service: ${{ steps.env.outputs.ecs_service }}
      task_definition: ${{ steps.env.outputs.task_definition }}
    steps:
      - name: Determine Environment
        id: env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            environment="${{ inputs.environment }}"
            should_deploy="true"
          elif [[ "${{ github.event_name }}" == "push" ]]; then
            environment="staging"
            should_deploy="true"
          elif [[ "${{ github.event_name }}" == "pull_request" ]]; then
            environment="staging"
            should_deploy="false" # Only build and test for PRs
          fi
          
          # Set environment-specific values
          case "$environment" in
            "staging")
              ecs_service="$ECS_SERVICE_STAGING"
              task_definition="clos-core-api-staging-task"
              ;;
            "production")
              ecs_service="$ECS_SERVICE_PRODUCTION"
              task_definition="clos-core-api-production-task"
              ;;
          esac
          
          echo "environment=$environment" >> $GITHUB_OUTPUT
          echo "should_deploy=$should_deploy" >> $GITHUB_OUTPUT
          echo "ecs_service=$ecs_service" >> $GITHUB_OUTPUT
          echo "task_definition=$task_definition" >> $GITHUB_OUTPUT
          
          echo "Environment: $environment" >> $GITHUB_STEP_SUMMARY
          echo "Will deploy: $should_deploy" >> $GITHUB_STEP_SUMMARY

  build-and-test:
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.meta.outputs.tags }}
      image_digest: ${{ steps.build.outputs.digest }}
      tests_passed: ${{ steps.test.outputs.passed }}
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: services/clos-core-api/package-lock.json
          
      - name: Install Dependencies
        working-directory: services/clos-core-api
        run: |
          npm ci
          npx prisma generate
          
      - name: Lint Code
        working-directory: services/clos-core-api
        run: |
          npm run lint
          npm run type-check
          
      - name: Run Unit Tests
        id: test
        working-directory: services/clos-core-api
        run: |
          npm run test:coverage
          
          # Check coverage thresholds
          coverage_percentage=$(npx nyc report --reporter=json | jq '.total.lines.pct')
          
          if (( $(echo "$coverage_percentage >= 80" | bc -l) )); then
            echo "✅ Test coverage: ${coverage_percentage}%" >> $GITHUB_STEP_SUMMARY
            echo "passed=true" >> $GITHUB_OUTPUT
          else
            echo "❌ Test coverage below 80%: ${coverage_percentage}%" >> $GITHUB_STEP_SUMMARY
            if [[ "${{ inputs.force_deploy }}" != "true" ]]; then
              echo "passed=false" >> $GITHUB_OUTPUT
              exit 1
            else
              echo "⚠️ Proceeding due to force_deploy=true" >> $GITHUB_STEP_SUMMARY
              echo "passed=true" >> $GITHUB_OUTPUT
            fi
          fi
          
      - name: Security Scan
        working-directory: services/clos-core-api
        run: |
          npm audit --audit-level=high
          
          # Run additional security checks
          npx semgrep --config=auto src/ || true
          
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
        
      - name: Extract Metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha
            type=raw,value=latest,enable={{is_default_branch}}
            
      - name: Build and Push Docker Image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: services/clos-core-api
          file: services/clos-core-api/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            NODE_ENV=production
            BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
            GIT_COMMIT=${{ github.sha }}
            
      - name: Run Container Security Scan
        run: |
          # Scan the built image for vulnerabilities
          image_uri="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ github.sha }}"
          
          # Use AWS ECR image scanning
          aws ecr start-image-scan --repository-name ${{ env.ECR_REPOSITORY }} --image-id imageTag=${{ github.sha }} || true
          
          # Wait for scan to complete
          sleep 30
          
          # Get scan results
          scan_results=$(aws ecr describe-image-scan-findings --repository-name ${{ env.ECR_REPOSITORY }} --image-id imageTag=${{ github.sha }} --output json || echo '{}')
          
          high_vulns=$(echo "$scan_results" | jq '.imageScanFindings.findingCounts.HIGH // 0')
          critical_vulns=$(echo "$scan_results" | jq '.imageScanFindings.findingCounts.CRITICAL // 0')
          
          echo "🔍 Container Scan Results:" >> $GITHUB_STEP_SUMMARY
          echo "- Critical: $critical_vulns" >> $GITHUB_STEP_SUMMARY
          echo "- High: $high_vulns" >> $GITHUB_STEP_SUMMARY
          
          # Block deployment if critical vulnerabilities found
          if [[ "$critical_vulns" -gt 0 ]] && [[ "${{ inputs.force_deploy }}" != "true" ]]; then
            echo "❌ Critical vulnerabilities found, blocking deployment" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi

  integration-tests:
    runs-on: ubuntu-latest
    needs: build-and-test
    if: needs.build-and-test.outputs.tests_passed == 'true'
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: clos_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: services/clos-core-api/package-lock.json
          
      - name: Install Dependencies
        working-directory: services/clos-core-api
        run: npm ci
        
      - name: Run Database Migrations
        working-directory: services/clos-core-api
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/clos_test
        run: |
          npx prisma migrate deploy
          npx prisma generate
          
      - name: Run Integration Tests
        working-directory: services/clos-core-api
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/clos_test
          REDIS_URL: redis://localhost:6379
          NODE_ENV: test
        run: |
          npm run test:integration
          
          echo "✅ Integration tests passed" >> $GITHUB_STEP_SUMMARY

  deploy-staging:
    runs-on: ubuntu-latest
    needs: [determine-environment, build-and-test, integration-tests]
    if: needs.determine-environment.outputs.should_deploy == 'true' && needs.determine-environment.outputs.environment == 'staging'
    environment: staging
    outputs:
      deployment_url: ${{ steps.deploy.outputs.url }}
    steps:
      - uses: actions/checkout@v4
      
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          
      - name: Download Task Definition
        id: download-task-def
        run: |
          aws ecs describe-task-definition --task-definition ${{ needs.determine-environment.outputs.task_definition }} --query taskDefinition > task-definition.json
          
      - name: Update Task Definition
        id: update-task-def
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        with:
          task-definition: task-definition.json
          container-name: ${{ env.CONTAINER_NAME }}
          image: ${{ needs.build-and-test.outputs.image_tag }}
          environment-variables: |
            NODE_ENV=staging
            LOG_LEVEL=info
            SENTRY_ENVIRONMENT=staging
            
      - name: Deploy to ECS
        id: deploy
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        with:
          task-definition: ${{ steps.update-task-def.outputs.task-definition }}
          service: ${{ needs.determine-environment.outputs.ecs_service }}
          cluster: ${{ env.ECS_CLUSTER }}
          wait-for-service-stability: true
          wait-for-minutes: 10
          
      - name: Get Service URL
        id: get-url
        run: |
          # Get load balancer URL for the service
          service_arn=$(aws ecs describe-services --cluster ${{ env.ECS_CLUSTER }} --services ${{ needs.determine-environment.outputs.ecs_service }} --query 'services[0].serviceArn' --output text)
          
          # This would typically involve getting the ALB DNS name
          # For now, use a placeholder
          service_url="https://api-staging.candlefish.ai"
          
          echo "url=$service_url" >> $GITHUB_OUTPUT
          echo "✅ Deployed to staging: $service_url" >> $GITHUB_STEP_SUMMARY

  health-check-staging:
    runs-on: ubuntu-latest
    needs: deploy-staging
    steps:
      - name: Wait for Service to be Ready
        run: |
          service_url="${{ needs.deploy-staging.outputs.deployment_url }}"
          
          echo "⏳ Waiting for service to be healthy..."
          
          # Wait up to 5 minutes for service to respond
          for i in {1..30}; do
            if curl -f -s "$service_url/health" > /dev/null; then
              echo "✅ Service is healthy" >> $GITHUB_STEP_SUMMARY
              break
            fi
            
            if [[ $i -eq 30 ]]; then
              echo "❌ Service failed health check after 5 minutes" >> $GITHUB_STEP_SUMMARY
              exit 1
            fi
            
            echo "Attempt $i/30 - waiting 10s..."
            sleep 10
          done
          
      - name: Run Smoke Tests
        run: |
          service_url="${{ needs.deploy-staging.outputs.deployment_url }}"
          
          # Test core endpoints
          echo "🧪 Running smoke tests..."
          
          # Health endpoint
          health_response=$(curl -s "$service_url/health")
          if [[ "$(echo $health_response | jq -r '.status')" == "ok" ]]; then
            echo "✅ Health check passed" >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ Health check failed" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi
          
          # GraphQL introspection
          if curl -f -s -X POST "$service_url/graphql" -H "Content-Type: application/json" -d '{"query":"query{__schema{types{name}}}"}' > /dev/null; then
            echo "✅ GraphQL endpoint accessible" >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ GraphQL endpoint failed" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi

  deploy-production:
    runs-on: ubuntu-latest
    needs: [determine-environment, build-and-test, integration-tests, health-check-staging]
    if: needs.determine-environment.outputs.environment == 'production' && github.ref == 'refs/heads/main'
    environment: production
    steps:
      - uses: actions/checkout@v4
      
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          
      - name: Create Deployment Backup
        run: |
          # Create backup of current task definition
          current_task_def=$(aws ecs describe-services --cluster ${{ env.ECS_CLUSTER }} --services ${{ env.ECS_SERVICE_PRODUCTION }} --query 'services[0].taskDefinition' --output text)
          
          aws ecs describe-task-definition --task-definition "$current_task_def" > "backup-task-definition-$(date +%Y%m%d-%H%M%S).json"
          
          echo "💾 Created backup of current deployment" >> $GITHUB_STEP_SUMMARY
          
      - name: Blue-Green Deployment
        run: |
          echo "🔄 Starting blue-green deployment to production..."
          
          # This would implement a proper blue-green deployment
          # For now, use the standard deployment process
          
          # Download current task definition
          aws ecs describe-task-definition --task-definition ${{ needs.determine-environment.outputs.task_definition }} --query taskDefinition > task-definition.json
          
          # Update image reference
          jq --arg IMAGE "${{ needs.build-and-test.outputs.image_tag }}" '.containerDefinitions[0].image = $IMAGE' task-definition.json > updated-task-definition.json
          
          # Register new task definition
          new_task_def=$(aws ecs register-task-definition --cli-input-json file://updated-task-definition.json --query 'taskDefinition.taskDefinitionArn' --output text)
          
          # Update service
          aws ecs update-service --cluster ${{ env.ECS_CLUSTER }} --service ${{ env.ECS_SERVICE_PRODUCTION }} --task-definition "$new_task_def"
          
          # Wait for deployment to complete
          aws ecs wait services-stable --cluster ${{ env.ECS_CLUSTER }} --services ${{ env.ECS_SERVICE_PRODUCTION }}
          
          echo "✅ Production deployment completed" >> $GITHUB_STEP_SUMMARY

  health-check-production:
    runs-on: ubuntu-latest
    needs: deploy-production
    steps:
      - name: Production Health Verification
        run: |
          prod_url="https://api.candlefish.ai"
          
          echo "🏥 Verifying production health..."
          
          # Extended health checks for production
          for i in {1..10}; do
            health_response=$(curl -s "$prod_url/health" || echo '{"status":"error"}')
            status=$(echo $health_response | jq -r '.status // "error"')
            
            if [[ "$status" == "ok" ]]; then
              echo "✅ Production health check passed" >> $GITHUB_STEP_SUMMARY
              break
            fi
            
            if [[ $i -eq 10 ]]; then
              echo "❌ Production health check failed - initiating rollback" >> $GITHUB_STEP_SUMMARY
              
              # Trigger rollback
              curl -X POST -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                -H "Accept: application/vnd.github.v3+json" \
                "${{ github.api_url }}/repos/${{ github.repository }}/actions/workflows/clos-rollback.yml/dispatches" \
                -d '{"ref":"main","inputs":{"service":"clos-core-api","environment":"production"}}' || true
              
              exit 1
            fi
            
            sleep 30
          done

  update-monitoring:
    runs-on: ubuntu-latest
    needs: [deploy-staging, deploy-production]
    if: always() && (needs.deploy-staging.result == 'success' || needs.deploy-production.result == 'success')
    steps:
      - name: Update Monitoring Dashboards
        run: |
          # Update deployment markers in monitoring systems
          environment="${{ needs.determine-environment.outputs.environment }}"
          image_tag="${{ needs.build-and-test.outputs.image_tag }}"
          
          # Send deployment event to monitoring
          curl -X POST "https://api.datadog.com/api/v1/events" \
            -H "DD-API-KEY: ${{ secrets.DATADOG_API_KEY }}" \
            -H "Content-Type: application/json" \
            -d "{
              \"title\": \"CLOS API Deployment - $environment\",
              \"text\": \"Deployed $image_tag to $environment\",
              \"tags\": [\"environment:$environment\", \"service:clos-core-api\", \"deployment\"],
              \"alert_type\": \"info\"
            }" || true
          
          echo "📊 Updated monitoring dashboards" >> $GITHUB_STEP_SUMMARY

  notify-deployment:
    runs-on: ubuntu-latest
    needs: [determine-environment, deploy-staging, deploy-production, health-check-production]
    if: always()
    steps:
      - name: Send Slack Notification
        if: env.SLACK_WEBHOOK_URL
        run: |
          environment="${{ needs.determine-environment.outputs.environment }}"
          
          # Determine deployment status
          if [[ "${{ needs.deploy-production.result }}" == "success" ]]; then
            status="SUCCESS"
            color="good"
            emoji="🚀"
            url="https://api.candlefish.ai"
          elif [[ "${{ needs.deploy-staging.result }}" == "success" ]]; then
            status="SUCCESS"
            color="good" 
            emoji="🧪"
            url="${{ needs.deploy-staging.outputs.deployment_url }}"
          else
            status="FAILED"
            color="danger"
            emoji="💥"
            url="N/A"
          fi
          
          curl -X POST "$SLACK_WEBHOOK_URL" \
            -H 'Content-type: application/json' \
            -d "{
              \"channel\": \"#deployments\",
              \"text\": \"CLOS API Deployment - $status\",
              \"attachments\": [{
                \"color\": \"$color\",
                \"title\": \"$emoji CLOS Core API - $environment\",
                \"text\": \"Deployment $status\",
                \"fields\": [
                  {\"title\": \"Environment\", \"value\": \"$environment\", \"short\": true},
                  {\"title\": \"Status\", \"value\": \"$status\", \"short\": true},
                  {\"title\": \"URL\", \"value\": \"$url\", \"short\": false},
                  {\"title\": \"Commit\", \"value\": \"${{ github.sha }}\", \"short\": true}
                ],
                \"footer\": \"CLOS v2.0 Deployment Pipeline\"
              }]
            }" || true